# Apr 23rd :-) 2019 trying to read movebank data using move


#### loading packages #######
library(move)#for downloading data
library(mapproj);library(ggmap) #these packages are necessary to work with google maps
library(spatsoc);library("asnipe");library("igraph"); # for working with the SN parts
library(reshape);library(data.table) #for the manual section where i build the SN myself
library(adehabitatLT);
source('C:/Users/nitik/Box Sync/Manuscript4_Vulture Data/VulturesCodes-master/MyCodes/createDirectedMatrices.R')
#source('C:/Users/nitik/Box Sync/Manuscript4_Vulture Data/VulturesCodes-master/MyCodes/createMatrices.R')
#require(dplyr) 
#require(tidyverse) 

#### key paramterer values ######
MaxSpeedPermited=120 #in movebank units (m/s??) anything above this will be filtered

#load('movebankPW.rdata')#the PW for movebank
VulturesToPlotMap=1:15 #1:length(unstackedOhad) #out of the vultures in the DB which one to plot? choose a few out of the 83
DistThreshold=250 #changed from 2000 in meters ---at what distance two indi are interacting ~ identifying another vulture on the Ohad 
#(colin pennyquick, 1974)
TimeThreshold='20 minutes' #in this format 'XX units'-- for spatsoc -- for Ohads, maybe 2 mins?? - timegroups - temporally overlapping
MinCoocurForValue=2; #miniimal number of coocurences for considering a viable pair- 
#given that they had the opportunity to interact at least 30 times we know they interacted-- 70 to 100 test sensitivity?- biologically relevant?
##from the data distribution?- start with arbitrary!

#### This is a function to help extract boundaries of home range/core areas

##defining a function "extractCoords" that helps extract coordinates of 50% polygon generated by adehabitatHR
extractCoords <- function(core_tot)
{
  results <- list()
  for(i in 1:length(core_tot@polygons[[1]]@Polygons))
  {
    results[[i]] <- core_tot@polygons[[1]]@Polygons[[i]]@coords
  }
  results <- Reduce(rbind, results)
  results
}
#thus, extracting for starters the polygon coods of k50_total so as to be able to calculate 
# the points falling in this polygon



###########   to create KDEs and measure areas in metres -- spatial transform to UTM ########
library(moveVis)
library(move)
BackStacked_All = df2move(Dataset_AllF,
                          proj = CRS(projection(AllBackStacked_All)), 
                          x = "coords.x1", y = "coords.x2", time = "timestamps", track_id = "trackId")
projection(BackStacked_All)#this was the original data projection from movebank
Dataset_AllF_wgs=Dataset_AllF;
coordinates(Dataset_AllF_wgs)<-~coords.x1+coords.x2
proj4string(Dataset_AllF_wgs)<-CRS(projection(BackStacked_All))

#proj4string(x) <-CRS("+proj=utm +zone=10+datum=WGS84")
#newData <- spTransform(x, CRS("+init=epsg:4238"))
utmS <- '+proj=utm +zone=36 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs' #south, but most points are in the north
utmN <- '+proj=utm +zone=36        +ellps=WGS84 +datum=WGS84 +units=m +no_defs'  #north

## converting to UTM36North, but note that not all points are within, just the majority
Dataset_AllF_utmN <- spTransform(Dataset_AllF_wgs, CRS(utmN))
head(coordinates(Dataset_AllF_utmN))#now the lat long are in metric
# just plotting the new dataset to see the locations look fine: plot(Dataset_AllF_utmN,col='blue')

## appending the new coordinates in easting northing- for calculating distance UTM locally
Dataset_AllF$Easting=coordinates(Dataset_AllF_utmN)[,1]
Dataset_AllF$Northing=coordinates(Dataset_AllF_utmN)[,2]


###### need to remove trackIds that have less than 5 relocations ####################

#DatasetAll5more<-subset(Dataset_AllF,
#                        with(Dataset_AllF,
#                             trackId %in% names(which(table(trackId) > 5))))

nrow(Dataset_AllF)



y = as.data.frame(cbind(trackId = rownames(as.data.frame(which(table(Dataset_AllF$trackId)<5)))))

DatasetAll5more<-subset(Dataset_AllF, trackId != "K94" & trackId != "T44.W")
#DatasetAll5more<-anti_join(Dataset_AllF, y)
DatasetAll5more$trackId<-factor(DatasetAll5more$trackId)

length(unique(Dataset_AllF$trackId))
length(unique(DatasetAll5more$trackId))

prj <- utmN
spdf <- SpatialPointsDataFrame(coordinates(cbind(DatasetAll5more$Easting, DatasetAll5more$Northing)),
                               data = DatasetAll5more, proj4string = CRS(prj))
# another quick plot
plot(spdf, pch = 19, cex = .5)
idsp<-data.frame(DatasetAll5more$trackId)
coordinates(idsp)<-spdf

kernel_tot<-kernelUD(idsp[,1], h = "href", grid = 64, hlim=c(0,3),
                     same4all = TRUE, kern = c("epa"), extent = 0.25)
par(mfcol=c(1,1))
image(kernel_tot)

Vultures2019_KDE50<-kernel.area(kernel_tot, percent=50)
Vultures2019_KDE95<-kernel.area(kernel_tot, percent=95)
setwd("C:/Users/nitik/Box Sync/Manuscript4_Vulture Data/VulturesCodes-master/MyOutputs/MovtPersonality")
#write.csv(t(Vultures2019_KDE50), "Vultures2019_KDE50.csv")
#write.csv(t(Vultures2019_KDE95), "Vultures2019_KDE95.csv")

# visualize individual utilization distribution:https://www.r-bloggers.com/2016/05/adehabitathr-visualization/


###################### Cut-off region ###############

##    plotting cut-off boundary   #########


setwd("C:/Users/nitik/Box Sync/Manuscript4_Vulture Data/KML_Files")
#FileName='201107_NewRoostsList.kml'
FileName='CutOffRegion.kml'
LayerName='Regional_polygon'
Outline = readOGR(dsn="C:/Users/nitik/Box Sync/Manuscript4_Vulture Data/KML_Files/CutOffRegion.kml", 
                  layer="CutOffRegion.kml")

####changing from WGS84 to UTM
Outline_coords<-as.data.frame(Outline@polygons[[1]]@Polygons[[1]]@coords)
colnames(Outline_coords)<-c("x","y")
projection(BackStacked_All)#this was the original data projection from movebank
Outline_coords_wgs=Outline_coords;
coordinates(Outline_coords_wgs)<-~x+y
proj4string(Outline_coords_wgs)<-CRS(projection(BackStacked_All))

#proj4string(x) <-CRS("+proj=utm +zone=10+datum=WGS84")
#newData <- spTransform(x, CRS("+init=epsg:4238"))
utmS <- '+proj=utm +zone=36 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs' #south, but most points are in the north
utmN <- '+proj=utm +zone=36        +ellps=WGS84 +datum=WGS84 +units=m +no_defs'  #north

## converting to UTM36North, but note that not all points are within, just the majority
Outline_coords_utm <- spTransform(Outline_coords_wgs, CRS(utmN))
head(coordinates(Outline_coords_utm))


##to avoid extent error
# 5. Domain                 HERE GRID IS INCREASED 50 AT X AND Y!!
x <- seq(min(DatasetAll5more$Easting), max(DatasetAll5more$Easting), by=75.) # resolution is the pixel size you desire 
y <- seq(min(DatasetAll5more$Northing), max(DatasetAll5more$Northing), by=75.)

memory.limit()#14283
memory.limit(size = (14283*4))
xy <- expand.grid(x=x,y=y)
memory.limit(size = (14283*4))
coordinates(xy) <- ~x+y
gridded(xy) <- TRUE
class(xy)




#########for each animal in 2019
ind.area50<-as.numeric()
ind.area95<-as.numeric()

pts.in<-as.numeric()
prop.obs<-as.numeric()
in.grids<-as.numeric()
tot.locs<-as.numeric()

animalId<-unique(DatasetAll5more$trackId)
length(animalId)
area50prop<-as.numeric()
ver_1<-as.numeric()
library(adehabitatHR)
pol.allx<-list()
pol.ally<-list()
mpol.x<-as.numeric()
mpol.y<-as.numeric()
ed_centre<-as.numeric()

centroids<-data.frame()
#rm(j)

#j = 2
for(j in 1:length(animalId)){ #loop on ALL individuals, now for plotting
  

  
  ###############Creating KERNEL DENSITY ESTIMATES TO STORE MOVT PERSONALITY = KDE50/KDE95 ##############
  
  
    dat1<-subset(DatasetAll5more, trackId==as.character(animalId[j])) #from my within nest datapts, subset the first animal's (id) datapts
    dat1 #data for only 1 animal
    
    head(dat1)
    if(nrow(dat1)>0){
    
    x1<-dat1$Easting
    y1<-dat1$Northing
    tot.locs[j]<-length(dat1$Easting) ##storing the total datapts
    xy1<-cbind(x1,y1)
    df1<-data.frame(X=xy1[,1],Y=xy1[,2])
    
    dfsp1 <- SpatialPoints(df1)
    idsp1<-data.frame(dat1[,2]) 
    sppt1<-data.frame(dfsp1)
    coordinates(idsp1)<-sppt1
    ##for each animal
    library(adehabitatHR)
    kernel_1<-kernelUD(dfsp1, h = "href", grid = xy, hlim=c(0,3),
                       same4all = FALSE, kern = c("epa")
                       , extent = 1.5
    )
    par(mfcol=c(1,1))
    image(kernel_1)
   
    
    
    core_1 <- getverticeshr(kernel_1, percent=50)
    ver_polys<-extractCoords(core_1)
  
    head(ver_polys)
    head(df1)
    point.x<-df1[,1] #so as to extract the x and y coods of the 50% UD
    point.y<-df1[,2]
    pol.x<-ver_polys[,1]
    pol.y<-ver_polys[,2]
    mpol.x[j]<-mean(pol.x)
    mpol.y[j]<-mean(pol.y)
    
    ##for each image
    #kernel_alt<-kernelUD(dfsp1, h = "href", grid = xy, hlim=c(0,3),
    #                   #same4all = TRUE, 
    #                   kern = c("epa")
    #                   , extent =1.5
    #)
    
    
    
    plot(core_1, #display="filled.contour2", 
         xlab="X", ylab="Y", add=T, lwd=1)
    points(dfsp1,col = "gray50", cex=0.2, pch=16, add=T) 
    points(mean(mpol.x[j]),mean(mpol.y[j]), col="blue", pch="*", cex= 3, add= TRUE)
    
    ##labelling the img
    library(calibrate)
    lab<-textxy(4,6,labs=animalId[j],cex=2)
    
    as.data.frame(core_1)
    ind.area50[j] <- kernel.area(kernel_1, percent=50)
    ind.area95[j] <- kernel.area(kernel_1, percent=95)
    
    ###volume of kernel- for IMG 2   #####
    vol_ud1 <- getvolumeUD(kernel_1)
    image(vol_ud1,cont=50, add= TRUE)
    points(dfsp1, cex=0.1, pch=16, col = "gray50")
    
    
    title(paste("Output of getvolumeUD for ",animalId[j],sep=""))
    xyzv1 <- as.image.SpatialGridDataFrame(vol_ud1)
    contour(xyzv1,col = "green", add=TRUE, percent=50)
    #contour(xyzv1,col = "brown", add=TRUE, percent=95)
    points(mean(mpol.x[j]),mean(mpol.y[j]), col="blue", pch="*", cex= 3, add= TRUE)
    centroids<-as.data.frame(rbind(centroids, as.data.frame(cbind(animalId[j], mean(mpol.x[j]),mean(mpol.y[j])))))
    
    ##labelling the img
    library(calibrate)
    lab<-textxy(4,7,labs=animalId[j],cex=2)
    
   
    
    ######### exporting KDEs #################
    setwd("C:/Users/nitik/Box Sync/Manuscript4_Vulture Data/VulturesCodes-master/MyOutputs/MovtPersonality")
    tiff(paste(animalId[j],".tiff", sep=""), units="in", width=8, height=5, res=300)
    
    plot(as.data.frame(Outline_coords_utm)$x,as.data.frame(Outline_coords_utm)$y, type = 'l',lty = 1, add=TRUE)
    
    image(vol_ud1,cont=50, add= TRUE)
    points(dfsp1, cex=0.1, pch=16, col = "gray50")
    
    
    title(paste("Output of getvolumeUD for ",animalId[j],sep=""))
    xyzv1 <- as.image.SpatialGridDataFrame(vol_ud1)
    contour(xyzv1,col = "green", add=TRUE, percent=50)
    #contour(xyzv1,col = "brown", add=TRUE, percent=95)
    points(mean(mpol.x[j]),mean(mpol.y[j]), col="blue", pch="*", cex= 3, add= TRUE)
    #contour(xyzv1, levels=50,add=TRUE, percent=50, col = "green",lwd=3,labcex=1, labels="50%")
    
    dev.off()
    
    ver_polys<-extractCoords(core_1)
    head(ver_polys)
    head(df1)
    point.x<-df1[,1] #so as to extract the x and y coods of the 50% UD
    point.y<-df1[,2]
    pol.x<-ver_polys[,1]
    pol.y<-ver_polys[,2]
    mpol.x[j]<-mean(pol.x)
    mpol.y[j]<-mean(pol.y)
   # ed_centre[j]<-sqrt((mpol.x[j]-mean(tot_pol.x))^2 + (mpol.y[j]-mean(tot_pol.y))^2)
    obs.pts<-point.in.polygon(point.x, point.y, pol.x, pol.y, mode.checked=FALSE) #how many pts fall within 50% UD
    obs.pts1<-subset(obs.pts,obs.pts=="1")
    obs.pts2<-subset(obs.pts,obs.pts=="2")
    pts.in[j]<-sum(obs.pts1)+length(obs.pts2)
    prop.obs[j]<-pts.in[j]/length(df1[,2]) #of all the pts observed for this animal, how many fall in 50% UD 
    #####
    
    
    pol.allx<-c(pol.allx, list(pol.x))
    pol.ally<-c(pol.ally, list(pol.y))
    Sys.sleep(1)
 
}#loop

}


